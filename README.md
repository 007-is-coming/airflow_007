# airflow_007

# ì˜¥íƒ‘ë°© í”Œë¦¬ ğŸ§

**`3ì°¨ 7íŒ€ â€˜007**â€™ **| ê¶Œì°¬ì†¡, ê¹€ìœ¤ì •, ì´ë¯¼ì§€, ì „ìˆ˜ë¯¼, ì†¡ê¸°ì›…, ìµœí˜œë¦¼**`

## I. í”„ë¡œì íŠ¸ ë°°ê²½ ë° ëª©í‘œ

<aside>

### **ğŸ” ê¸°ì¡´ ìŒì› ì‚¬ì´íŠ¸ì˜ ìŒì•… ì¶”ì²œ ê¸°ëŠ¥ì˜ í•œê³„**

- í•˜ë‚˜ì˜ ìŒì› ì‚¬ì´íŠ¸ ë‚´ì—ì„œë§Œ ëˆ„ì ëœ ë°ì´í„°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë…¸ë˜ë¥¼ ì¶”ì²œ ë°›ì„ ìˆ˜ ìˆìŒ
- ë‚´ê°€ ì›í•˜ëŠ” ë…¸ë˜ í•œ ê³¡ì— ëŒ€í•´ ì—¬ëŸ¬ê°€ì§€ ì‚¬ì´íŠ¸ì—ì„œ ì¶”ì²œí•˜ëŠ” ë…¸ë˜ë¥¼ ì°¾ê¸° í˜ë“¦

### **ğŸ‘¤ ë‹¤ì–‘í•œ í”Œë«í¼ì˜ ë°ì´í„°ë¥¼ í™œìš©í•œ í†µí•© ì¶”ì²œ**

- ìœ íŠœë¸Œì™€ ìŠ¤í¬í‹°íŒŒì´ì˜ ê°•ì ì„ ê²°í•©í•˜ì—¬ ì‚¬ìš©ìì—ê²Œ **`í•œ í”Œë«í¼ì„ ë„˜ì–´ì„  í­ë„“ì€ ì¶”ì²œ ì„œë¹„ìŠ¤`** ì œê³µ
- ê° í”Œë«í¼ì˜ íŠ¹ì„±(ì»¤ë²„ê³¡, ì „ë¬¸ íë ˆì´íŒ… ë“±)ì„ ë°˜ì˜í•œ **`ìµœì í™”ëœ ì¶”ì²œ ê²½í—˜`** ì œê³µ
</aside>

## II. í™œìš© ê¸°ìˆ  ë° í”„ë¡œì íŠ¸ êµ¬ì¡°

<aside>

| TASK | í™œìš© ê¸°ìˆ  | ë¹„ê³  |
| --- | --- | --- |
| Data Collection | Python, SQL | **`Spotify API`**, **`Youtube API`**ì‚¬ìš© |
| Data Preprocessing | Python, SQL | API í˜¸ì¶œ í›„ ë°ì´í„°ë² ì´ìŠ¤ì— ë§ê²Œ ë³€ê²½ |
| Data Warehouse(DB) | On-premise  | **`Postgre`** APIë¥¼ í†µí•´ ê°€ì§€ê³  ì˜¨ ë°ì´í„° ì ì¬ |
| Visualization | Django | **`Web Page`** ê²€ìƒ‰ ë° ì¶”ì²œ ê²°ê³¼ ì¶œë ¥ |
| Team Management | Notion, Discord, Github, VSCode | **`Notion`**í”„ë¡œì íŠ¸ íšŒì˜ ê¸°ë¡, í”„ë¡œì íŠ¸ ë³´ê³ ì„œ ì‘ì„±
**`Discord`** í”„ë¡œì íŠ¸ íšŒì˜ ë° ì‹¤ì‹œê°„ ê³µìœ 
**`Github`** í”„ë¡œì íŠ¸ ê²°ê³¼ë¬¼ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
**`VSCode`** live shareë¥¼ í†µí•´ ì‹¤ì‹œê°„ìœ¼ë¡œ ì½”ë“œ ê³µìœ  ë° í˜‘ì—… |

### âš™ System Architecture

![[í”„ë¡œê·¸ë˜ë¨¸ìŠ¤] 3ì°¨ 7íŒ€ í”„ë¡œì íŠ¸ ê°œë°œ ì•„í‚¤í…ì²˜ (1).jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/29dd0948-7b38-443b-af5a-c6bc908226ab/54afbed8-5a11-4f98-a17b-e18f17c51313/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_3%EC%B0%A8_7%ED%8C%80_%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8_%EA%B0%9C%EB%B0%9C_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98_(1).jpg)

</aside>

## III. ê²°ê³¼ë¬¼

### **ğŸ“Š Web Page Demonstration Video**

<aside>

- **`Demonstration video`**
    
    [á„’á…ªá„†á…§á†« á„€á…µá„…á…©á†¨ 2024-11-27 13.01.27.mov](https://prod-files-secure.s3.us-west-2.amazonaws.com/29dd0948-7b38-443b-af5a-c6bc908226ab/2b6e86d3-adff-4c0a-ab1c-9dbaf98174d5/%E1%84%92%E1%85%AA%E1%84%86%E1%85%A7%E1%86%AB_%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%E1%86%A8_2024-11-27_13.01.27.mov)
    
</aside>

### **ğŸ“Š Web Page Screenshot**

<aside>

- **`Main`**
    
    ![home_page.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/29dd0948-7b38-443b-af5a-c6bc908226ab/064d60a5-b6a5-454b-8027-d5a4ffa432de/a1e7ce11-c21d-48cc-a483-50dabbb83c75.png)
    
- **`Youtube`**
    
    ![result_page.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/29dd0948-7b38-443b-af5a-c6bc908226ab/de0c8b14-cb2e-4567-b397-678b3d20cd58/180db265-7c3b-4705-a0fd-1894bbffd4d3.png)
    
- **`Spotify`**
    
    ![result_page2.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/29dd0948-7b38-443b-af5a-c6bc908226ab/55e98ff0-d0b6-4358-9afe-e3fa75e5de0d/00d040a6-0865-4897-81ad-c4b5ced7792f.png)
    
- **`Play`**
    
    ![palyer.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/29dd0948-7b38-443b-af5a-c6bc908226ab/8ff25999-3dc0-42ff-83d1-db6ab89776b6/3f7e012e-4f8e-4db5-b799-b6c03cf0f992.png)
    
</aside>

### **ğŸ“Š Presentation**

<aside>

https://www.canva.com/design/DAGXjmUbIOk/qWKyaSuho3Reux-sdDO_Vw/view

</aside>

## IV. í”„ë¡œì íŠ¸ ì„¸ë¶€ ë‚´ìš©

<aside>

### **ğŸ”¶ ERD**

![3.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/29dd0948-7b38-443b-af5a-c6bc908226ab/6062b889-cf0e-4942-8daf-b189404c3208/4e21d835-5db4-43bf-b9d2-1c2cf53790db.png)

### **âš’ ê°œë°œ ë‹¨ê³„ë³„ TASK**

- **Step1. ë°ì´í„° ìˆ˜ì§‘ ë° ì „ì²˜ë¦¬**
    - **ë°ì´í„° ìˆ˜ì§‘**
        
        
        | Data Name | Source | Update Date | Description |
        | --- | --- | --- | --- |
        | spotify_playlist | spotify api | trigger (django) ë°œìƒ ì‹œ  | ê²€ìƒ‰ì–´ì¸ ë…¸ë˜ë¥¼ í¬í•¨í•˜ëŠ” playlist |
        | spotify_recommend | spotify api | trigger (django) ë°œìƒ ì‹œ | ê²€ìƒ‰ì–´ì¸ ë…¸ë˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ recommendëœ ë…¸ë˜ |
        | search_youtube_playlist | youtube api | trigger (django) ë°œìƒ ì‹œ | ê²€ìƒ‰ì–´ì¸ ë…¸ë˜ë¥¼ í¬í•¨í•˜ëŠ” playlist (music ê²€ìƒ‰ì–´) |
        | search_youtube_video | youtube api | trigger (django) ë°œìƒ ì‹œ  | ê²€ìƒ‰ì–´ì¸ ë…¸ë˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ recommendëœ video (music ê²€ìƒ‰ì–´) |
        | spotify_today_tracks | spotify api | ë§¤ì¼ ìì • | ë§¤ì¼ global top 50ì—ì„œ ìƒìœ„ 10ê°œì˜ ë…¸ë˜  |
        | spotify_today_playlists | spotify api | ë§¤ì¼ ìì • | ë§¤ì¼ â€˜topâ€™ì„ í¬í•¨í•˜ëŠ” ìƒìœ„ 10ê°œì˜ playlist |
        | daily_youtube_video | youtube api | ë§¤ì¼ ìì • | ë§¤ì¼ global top video ì¤‘ ìƒìœ„ 10ê°œ (music ê²€ìƒ‰ì–´) |
    - **ë°ì´í„° ì „ì²˜ë¦¬**
        
        
        | Data Set | ê¸°ì¡´ Column | ì „ì²˜ë¦¬ í›„ Column | ì „ì²˜ë¦¬ ë‚´ìš© |
        | --- | --- | --- | --- |
        | spotify_playlist / search_youtube_playlist  | no, title, link, cover_image / no, playlist_title, playlist_id, playlist_thumbnail | no, playlist_title, playlist_url, thumbnail, platform | youtubeì™€ spotifyì—ì„œ ê°€ì§€ê³ ì˜¨ ë°ì´í„°ë¥¼ í•˜ë‚˜ì˜ í…Œì´ë¸”ë¡œ í†µí•© |
        | spotify_recommend / search_youtube_video | no, title, link, cover_image / no, video_title, video_id | no, song_title, song_url, thumbnail, platform | youtubeì™€ spotifyì—ì„œ ê°€ì§€ê³ ì˜¨ ë°ì´í„°ë¥¼ í•˜ë‚˜ì˜ í…Œì´ë¸”ë¡œ í†µí•© |
        | spotify_today_tracks / daily_youtube_video | no, title, link, cover_image /  no, video_title, video_id | no, song_title, song_url, thumbnail, platform | youtubeì™€ spotifyì—ì„œ ê°€ì§€ê³ ì˜¨ ë°ì´í„°ë¥¼ í•˜ë‚˜ì˜ í…Œì´ë¸”ë¡œ í†µí•© |
- **Step2. ë°ì´í„° ì ì¬**
    
    ğŸ“‹**Airflowë¥¼ í™œìš©í•œ Dag ì‚¬ìš©ìœ¼ë¡œ ë°ì´í„° ìë™ ì ì¬**
    
    > **`ğŸ“ˆ playlist_schema ë° django_schema ë°ì´í„° ì ì¬`**
    > 
    > - [**`daily_songs_dag.py`**] `Spotify ì˜¤ëŠ˜ì˜ Top 10 track ë° Youtube ì˜¤ëŠ˜ì˜ Top 10 video (ë§¤ì¼ ìì • ê°±ì‹ )`
    >     
    >     ```python
    >     ## daily songë§Œ ê°€ì ¸ì˜¤ëŠ” ë¶€ë¶„ìœ¼ë¡œ ë³€ê²½
    >     
    >     import os
    >     import spotipy
    >     from airflow.models import Variable
    >     from airflow import DAG
    >     from airflow.operators.python import PythonOperator
    >     from airflow.providers.postgres.hooks.postgres import PostgresHook
    >     from datetime import datetime, timedelta
    >     from youtube_class import YoutubeClient
    >     from spotify_class import SpotifyClient
    >     import psycopg2
    >     import pandas as pd
    >     from io import StringIO
    >     import csv
    >     import logging
    >     
    >     # ë¡œê¹… ì„¤ì •
    >     logging.basicConfig(
    >         level=logging.INFO,  # ë¡œê·¸ ë ˆë²¨ì„ INFOë¡œ ì„¤ì •
    >         format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    >     )
    >     logger = logging.getLogger(__name__)
    >     
    >     def extract_data_from_site():
    >         """ Youtubeì—ì„œ top10ì„ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜ """
    >         youtube_client = YoutubeClient()
    >         daily_youtube_video_df, daily_youtube_playlist_df = youtube_client.daily_youtube()
    >         logger.info(f"youtube daily _ youtube ë°ì¼ë¦¬ ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤: {daily_youtube_video_df}, {daily_youtube_playlist_df}")
    >         
    >         """ Spotifyì—ì„œ top10ì„ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜ """
    >         spotify_client = SpotifyClient()
    >         top_tracks = spotify_client.get_top_10_tracks_from_playlist()
    >         logger.info(f"spotify today track _ ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤: {top_tracks}")
    >         
    >         return daily_youtube_video_df, top_tracks
    >         
    >     def bulk_insert_table(cursor, conn, df, table_name):
    >         """
    >         ë°ì´í„°í”„ë ˆì„ì„ PostgreSQL í…Œì´ë¸”ì— COPY ëª…ë ¹ìœ¼ë¡œ ë¹ ë¥´ê²Œ ì‚½ì….
    >         """
    >         # ë°ì´í„°í”„ë ˆì„ì„ CSV í˜•ì‹ìœ¼ë¡œ ë©”ëª¨ë¦¬ì— ì €ì¥
    >         buffer = StringIO()
    >         df.to_csv(buffer, index=False, header=False, quotechar='"', quoting=csv.QUOTE_ALL)
    >         buffer.seek(0)
    >     
    >         try:
    >             # COPY ëª…ë ¹ ì‹¤í–‰
    >             cursor.copy_expert(f"COPY {table_name} FROM STDIN WITH CSV", buffer)
    >             logger.info(f"youtube daily _ í…Œì´ë¸” {table_name}ì— ë°ì´í„° ì‚½ì… ì™„ë£Œ")
    >         except Exception as e:
    >             # ì—ëŸ¬ ë°œìƒ ì‹œ íŠ¸ëœì­ì…˜ ë¡¤ë°±
    >             conn.rollback()
    >             print(f"youtube daily _ {table_name} ì‚½ì… ì˜¤ë¥˜: {e}")
    >         finally:
    >             buffer.close()
    >     
    >     def transform_schema(cursor):
    >         # daily_songs
    >         # 1. í…Œì´ë¸” ì‚­ì œ
    >         drop_table_query = "DROP TABLE IF EXISTS django_schema.daily_songs;"
    >         cursor.execute(drop_table_query)
    >     
    >         # 2. í…Œì´ë¸” ìƒì„±
    >         create_table_query = """
    >         CREATE TABLE django_schema.daily_songs (
    >             no SERIAL PRIMARY KEY,
    >             song_title VARCHAR(255) NOT NULL,
    >             song_url VARCHAR(255) NOT NULL,
    >             thumbnail VARCHAR(255),
    >             platform VARCHAR(255) NOT NULL
    >         );
    >         """
    >         cursor.execute(create_table_query)
    >     
    >         # daily_youtube_video ë°ì´í„° ì‚½ì…
    >         youtube_query = """
    >         INSERT INTO django_schema.daily_songs (song_title, song_url, thumbnail, platform)
    >         SELECT 
    >             video_title AS song_title,
    >             video_id AS song_url,
    >             CONCAT('https://img.youtube.com/vi/', video_id, '/0.jpg') AS thumbnail,
    >             'youtube' AS platform
    >         FROM playlist_schema.daily_youtube_video;
    >         """
    >         cursor.execute(youtube_query)
    >     
    >         # spotify_today_tracks ë°ì´í„° ì‚½ì…
    >         spotify_query = """
    >         INSERT INTO django_schema.daily_songs (song_title, song_url, thumbnail, platform)
    >         SELECT 
    >             title AS song_title,
    >             link AS song_url,
    >             cover_image AS thumbnail,
    >             'spotify' AS platform
    >         FROM playlist_schema.spotify_today_tracks;
    >         """
    >         cursor.execute(spotify_query)
    >         return
    >     
    >     def load_data_to_db(daily_youtube_video_df, top_tracks):
    >         """ ë°ì´í„°ë² ì´ìŠ¤ì— ë°ì´í„° ë¡œë“œ """
    >         if daily_youtube_video_df.empty:
    >             logger.warning("youtube daily _ ë¹ˆ í…Œì´ë¸”ì´ ìˆìŠµë‹ˆë‹¤.")
    >             return
    >         if not top_tracks:
    >             logger.warning("spotify today track _ ë¡œë“œí•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
    >             return
    >     
    >         pg_hook = PostgresHook(postgres_conn_id='playlist')  # ì—°ê²° ID ì‚¬ìš©
    >         conn_tmp = pg_hook.get_connection(pg_hook.postgres_conn_id)
    >         try:
    >             # ì§ì ‘ psycopg2ë¡œ ì—°ê²°í•˜ê³  ì¸ì½”ë”©ì„ ì„¤ì •
    >             conn = psycopg2.connect(
    >                 host=conn_tmp.host,
    >                 database=conn_tmp.schema,
    >                 user=conn_tmp.login,
    >                 password=conn_tmp.password,
    >                 port=conn_tmp.port,
    >                 client_encoding='UTF8'  # ì¸ì½”ë”© ì„¤ì •
    >             )
    >             cursor = conn.cursor()
    >     
    >             # ê¸°ì¡´ songs í…Œì´ë¸” ë“œë¡­
    >             logger.info("youtube daily _ daily_youtube ê¸°ì¡´ í…Œì´ë¸” ì‚­ì œ ì¤‘...")
    >             cursor.execute("DROP TABLE IF EXISTS playlist_schema.daily_youtube_video;")
    >     
    >             # ê¸°ì¡´ songs í…Œì´ë¸” ë“œë¡­
    >             logger.info("spotify today track _ ê¸°ì¡´ í…Œì´ë¸” ì‚­ì œ ì¤‘...")
    >             cursor.execute("DROP TABLE IF EXISTS playlist_schema.spotify_today_tracks")
    >     
    >             # songs í…Œì´ë¸” ìƒì„± (noëŠ” SERIAL PKë¡œ ì„¤ì •)
    >             logger.info("youtube daily _ daily_youtube ìƒˆ í…Œì´ë¸” ìƒì„± ì¤‘...")
    >             cursor.execute("""
    >                 CREATE TABLE IF NOT EXISTS playlist_schema.daily_youtube_video (
    >                     no SERIAL PRIMARY KEY,
    >                     video_title VARCHAR(255),
    >                     video_id VARCHAR(255)
    >                 );
    >             """)
    >             logger.info("youtube daily _ ìƒˆ í…Œì´ë¸” ìƒì„± ì™„ë£Œ")
    >     
    >             # songs í…Œì´ë¸” ìƒì„± (noëŠ” SERIAL PKë¡œ ì„¤ì •)
    >             logger.info("spotify today track _ ìƒˆ í…Œì´ë¸” ìƒì„± ì¤‘...")
    >             create_table_query = """
    >             CREATE TABLE playlist_schema.spotify_today_tracks (
    >                 no SERIAL PRIMARY KEY,
    >                 title VARCHAR(256),
    >                 link VARCHAR(256),
    >                 cover_image VARCHAR(256)
    >             )
    >             """
    >             cursor.execute(create_table_query)
    >             logger.info("spotify today track _ ìƒˆ í…Œì´ë¸” ìƒì„± ì™„ë£Œ")
    >     
    >             # ë°ì´í„°ë¥¼ songs í…Œì´ë¸”ì— ì‚½ì…
    >             bulk_insert_table(cursor, conn, daily_youtube_video_df, 'playlist_schema.daily_youtube_video')
    >             logger.info("youtube daily _ ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ë°ì´í„°ë² ì´ìŠ¤ì— ì‚½ì…ë˜ì—ˆìŠµë‹ˆë‹¤.")
    >     
    >             # ë°ì´í„°ë¥¼ songs í…Œì´ë¸”ì— ì‚½ì…
    >             for song in top_tracks:
    >                 insert_query = """
    >                 INSERT INTO playlist_schema.spotify_today_tracks (title, link, cover_image)
    >                 VALUES (%s, %s, %s)
    >                 """
    >                 cursor.execute(insert_query, (song['title'], song['link'], song['cover_image']))
    >             logger.info("spotify today track _ ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ë°ì´í„°ë² ì´ìŠ¤ì— ì‚½ì…ë˜ì—ˆìŠµë‹ˆë‹¤.")
    >     
    >             transform_schema(cursor)
    >             conn.commit()
    >             
    >         except Exception as e:
    >             # ì˜ˆì™¸ ë°œìƒ ì‹œ ë¡¤ë°±
    >             logger.error(f"daily songs _ ë°ì´í„° ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
    >             conn.rollback()
    >     
    >         finally:
    >             # ì»¤ì„œì™€ ì—°ê²° ë‹«ê¸°
    >             cursor.close()
    >             conn.close()
    >             logger.info("daily songs _ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
    >         return
    >     
    >     # Airflow DAG ì •ì˜
    >     default_args = {
    >         'owner': 'airflow',
    >         'retries': 1,
    >         'retry_delay': timedelta(minutes=5),
    >         'start_date': datetime(2023, 11, 22),  # ì›í•˜ëŠ” ì‹œì‘ ë‚ ì§œ ì„¤ì •
    >     }
    >     
    >     dag = DAG(
    >         'etl_dag_daily_tracks',  # DAG ì´ë¦„
    >         default_args=default_args,
    >         description='ETL for daily tracks',
    >         schedule_interval='0 0 * * *',  # ìì • 
    >         catchup=False,  # ê³¼ê±°ì— ì‹¤í–‰ë˜ì§€ ì•Šì€ DAGë¥¼ ì‹¤í–‰í•˜ì§€ ì•Šë„ë¡ ì„¤ì •
    >     )
    >     
    >     # Airflow Task ì •ì˜
    >     def run_etl():
    >         daily_youtube_video_df, top_tracks = extract_data_from_site()
    >         load_data_to_db(daily_youtube_video_df, top_tracks)
    >     
    >     # DAG ì•ˆì—ì„œ Task ì—°ê²°
    >     etl_task = PythonOperator(
    >         task_id='etl_task_daily_tracks',
    >         python_callable=run_etl,
    >         dag=dag,
    >     )
    >     
    >     etl_task
    >     ```
    >     
    > - [**`spotify_today_playlists_dag.py`**] `Spotifyì˜ playlist ì¤‘ top í‚¤ì›Œë“œë¥¼ í¬í•¨í•˜ëŠ” playlist ì¤‘ ìƒìœ„ 10ê°œ (ë§¤ì¼ ìì • ê°±ì‹ )`
    >     
    >     ```python
    >     import os
    >     import spotipy
    >     from airflow.models import Variable
    >     from spotipy.oauth2 import SpotifyOAuth
    >     from airflow import DAG
    >     from airflow.operators.python import PythonOperator
    >     from airflow.providers.postgres.hooks.postgres import PostgresHook
    >     from datetime import datetime, timedelta
    >     from spotify_class import SpotifyClient
    >     import psycopg2
    >     import logging
    >     
    >     # ë¡œê¹… ì„¤ì •
    >     logging.basicConfig(
    >         level=logging.INFO,  # ë¡œê·¸ ë ˆë²¨ì„ INFOë¡œ ì„¤ì •
    >         format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    >     )
    >     logger = logging.getLogger(__name__)
    >     
    >     def extract_data_from_spotify():
    >         """ Spotifyì—ì„œ ì¶”ì²œê³¡ì„ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜ """
    >         spotify_client = SpotifyClient()
    >         today_playlists_data = spotify_client.get_top_10_playlists()
    >         logger.info(f"spotify today playlist _ ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤: {today_playlists_data}")
    >         return today_playlists_data
    >     
    >     def transform_schema(cursor):
    >         # daily_playlist
    >         # 1. í…Œì´ë¸” ì‚­ì œ
    >         drop_table_query = "DROP TABLE IF EXISTS django_schema.daily_playlists;"
    >         cursor.execute(drop_table_query)
    >     
    >         # 2. í…Œì´ë¸” ìƒì„±
    >         create_table_query = """
    >         CREATE TABLE django_schema.daily_playlists (
    >             no SERIAL PRIMARY KEY,
    >             playlist_title VARCHAR(255) NOT NULL,
    >             playlist_url VARCHAR(255) NOT NULL,
    >             thumbnail VARCHAR(255),
    >             platform VARCHAR(255) NOT NULL
    >         );
    >         """
    >         cursor.execute(create_table_query)
    >         
    >         # 3. spotify_today_playlists ë°ì´í„° ì‚½ì…
    >         spotify_query = """
    >         INSERT INTO django_schema.daily_playlists (playlist_title, playlist_url, thumbnail, platform)
    >         SELECT 
    >             title AS playlist_title,
    >             link AS playlist_url,
    >             cover_image AS thumbnail,
    >             'spotify' AS platform
    >         FROM playlist_schema.spotify_today_playlists;
    >         """
    >         cursor.execute(spotify_query)
    >         return
    >     
    >     def load_data_to_db(today_playlists_data):
    >         """ ë°ì´í„°ë² ì´ìŠ¤ì— ë°ì´í„° ë¡œë“œ """
    >         if not today_playlists_data:
    >             logger.warning("spotify today playlist _ ë¡œë“œí•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
    >             return
    >     
    >         pg_hook = PostgresHook(postgres_conn_id='playlist')  # ì—°ê²° ID ì‚¬ìš©
    >         conn_tmp = pg_hook.get_connection(pg_hook.postgres_conn_id)
    >         try:
    >             # ì§ì ‘ psycopg2ë¡œ ì—°ê²°í•˜ê³  ì¸ì½”ë”©ì„ ì„¤ì •
    >             conn = psycopg2.connect(
    >                 host=conn_tmp.host,
    >                 database=conn_tmp.schema,
    >                 user=conn_tmp.login,
    >                 password=conn_tmp.password,
    >                 port=conn_tmp.port,
    >                 client_encoding='UTF8'  # ì¸ì½”ë”© ì„¤ì •
    >             )
    >             cursor = conn.cursor()
    >     
    >             # ê¸°ì¡´ songs í…Œì´ë¸” ë“œë¡­
    >             logger.info("spotify today playlist _ ê¸°ì¡´ í…Œì´ë¸” ì‚­ì œ ì¤‘...")
    >             cursor.execute("DROP TABLE IF EXISTS playlist_schema.spotify_today_playlists")
    >     
    >             # songs í…Œì´ë¸” ìƒì„± (noëŠ” SERIAL PKë¡œ ì„¤ì •)
    >             logger.info("spotify today playlist _ ìƒˆ í…Œì´ë¸” ìƒì„± ì¤‘...")
    >             create_table_query = """
    >             CREATE TABLE playlist_schema.spotify_today_playlists (
    >                 no SERIAL PRIMARY KEY,
    >                 title VARCHAR(256),
    >                 link VARCHAR(256),
    >                 cover_image VARCHAR(256)
    >             )
    >             """
    >             cursor.execute(create_table_query)
    >             logger.info("spotify today playlist _ ìƒˆ í…Œì´ë¸” ìƒì„± ì™„ë£Œ")
    >     
    >             # ë°ì´í„°ë¥¼ songs í…Œì´ë¸”ì— ì‚½ì…
    >             for song in today_playlists_data:
    >                 insert_query = """
    >                 INSERT INTO playlist_schema.spotify_today_playlists (title, link, cover_image)
    >                 VALUES (%s, %s, %s)
    >                 """
    >                 cursor.execute(insert_query, (song['title'], song['link'], song['cover_image']))
    >     
    >             #django_schema insert
    >             transform_schema(cursor)
    >     
    >             conn.commit()
    >             logger.info("spotify today playlist _ ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ë°ì´í„°ë² ì´ìŠ¤ì— ì‚½ì…ë˜ì—ˆìŠµë‹ˆë‹¤.")
    >     
    >         except Exception as e:
    >             # ì˜ˆì™¸ ë°œìƒ ì‹œ ë¡¤ë°±
    >             logger.error(f"spotify today playlist _ ë°ì´í„° ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
    >             conn.rollback()
    >     
    >         finally:
    >             # ì»¤ì„œì™€ ì—°ê²° ë‹«ê¸°
    >             cursor.close()
    >             conn.close() 
    >             logger.info("spotify today playlist _ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
    >         return
    >     
    >     # Airflow DAG ì •ì˜
    >     default_args = {
    >         'owner': 'airflow',
    >         'retries': 1,
    >         'retry_delay': timedelta(minutes=5),
    >         'start_date': datetime(2023, 11, 22),  # ì›í•˜ëŠ” ì‹œì‘ ë‚ ì§œ ì„¤ì •
    >     }
    >     
    >     dag = DAG(
    >         'spotify_etl_dag_today_playlists',  # DAG ì´ë¦„
    >         default_args=default_args,
    >         description='ETL for Spotify today playlists',
    >         schedule_interval='0 0 * * *',  # ë§¤ì¼ ì˜¤í›„ 12ì‹œ ì •ê° ì‹¤í–‰ (CRON í‘œí˜„ì‹)
    >         catchup=False,  # ê³¼ê±°ì— ì‹¤í–‰ë˜ì§€ ì•Šì€ DAGë¥¼ ì‹¤í–‰í•˜ì§€ ì•Šë„ë¡ ì„¤ì •
    >     )
    >     
    >     # Airflow Task ì •ì˜
    >     def run_etl():
    >         today_play_list_data = extract_data_from_spotify()
    >         load_data_to_db(today_play_list_data)
    >     
    >     # DAG ì•ˆì—ì„œ Task ì—°ê²°
    >     etl_task = PythonOperator(
    >         task_id='spotify_etl_task_today_playlists',
    >         python_callable=run_etl,
    >         dag=dag,
    >     )
    >     
    >     etl_task
    >     ```
    >     
    > - [**`songs_dag.py`**] `ê²€ìƒ‰ì–´ ê¸°ë°˜ Spotify ì¶”ì²œ ìƒìœ„ 10ê°œ track / Spotify ì¶”ì²œ ëª©ë¡ 10ê°œ ê¸°ë°˜ Youtube ìƒìœ„ video (Django input trigger ê°±ì‹ )`
    >     
    >     ```python
    >     import os
    >     import spotipy
    >     from airflow.models import Variable
    >     from airflow import DAG
    >     from airflow.operators.python import PythonOperator
    >     from airflow.providers.postgres.hooks.postgres import PostgresHook
    >     from datetime import datetime, timedelta
    >     from youtube_class import YoutubeClient
    >     from spotify_class import SpotifyClient
    >     import psycopg2
    >     import pandas as pd
    >     from io import StringIO
    >     import csv
    >     import logging
    >     
    >     logging.basicConfig(
    >         level=logging.INFO,  # ë¡œê·¸ ë ˆë²¨ì„ INFOë¡œ ì„¤ì •
    >         format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    >     )
    >     logger = logging.getLogger(__name__)
    >     
    >     def extract_data_from_site(song_title):
    >         """ Spotifyì—ì„œ ì¶”ì²œê³¡ì„ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜ """
    >         spotify_client = SpotifyClient()
    >         recommendations_data, youtube_recommendations_data = spotify_client.get_recommendations(song_title)
    >         logger.info(f"spotify ì¶”ì²œê³¡ _ ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤: {recommendations_data}")
    >     
    >         """ Youtubeì—ì„œ ì¶”ì²œê³¡ì„ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜ """
    >         youtube_client = YoutubeClient()
    >         search_video_df = youtube_client.search_youtube(youtube_recommendations_data)
    >         logger.info(f"youtube ì¶”ì²œê³¡ _ ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤: {search_video_df}")
    >         
    >         return search_video_df, recommendations_data
    >     
    >     def bulk_insert_table(cursor, conn, df, table_name):
    >         """
    >         ë°ì´í„°í”„ë ˆì„ì„ PostgreSQL í…Œì´ë¸”ì— COPY ëª…ë ¹ìœ¼ë¡œ ë¹ ë¥´ê²Œ ì‚½ì….
    >         """
    >         # ë°ì´í„°í”„ë ˆì„ì„ CSV í˜•ì‹ìœ¼ë¡œ ë©”ëª¨ë¦¬ì— ì €ì¥
    >         buffer = StringIO()
    >         df.to_csv(buffer, index=False, header=False, quotechar='"', quoting=csv.QUOTE_ALL)
    >         buffer.seek(0)
    >     
    >         try:
    >             # COPY ëª…ë ¹ ì‹¤í–‰
    >             cursor.copy_expert(f"COPY {table_name} FROM STDIN WITH CSV", buffer)
    >             logger.info(f"youtube ê²€ìƒ‰ _ í…Œì´ë¸” {table_name}ì— ë°ì´í„° ì‚½ì… ì™„ë£Œ")
    >         except Exception as e:
    >             # ì—ëŸ¬ ë°œìƒ ì‹œ íŠ¸ëœì­ì…˜ ë¡¤ë°±
    >             conn.rollback()
    >             logger.error(f"youtube ê²€ìƒ‰ _ {table_name} ì‚½ì… ì˜¤ë¥˜: {e}")
    >         finally:
    >             buffer.close()
    >     
    >     def transform_schema(cursor):
    >         # search_songs
    >         # 1. í…Œì´ë¸” ì‚­ì œ
    >         logger.info(f" search songs : ë°ì´í„°ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.")
    >         drop_table_query = "DROP TABLE IF EXISTS django_schema.search_songs;"
    >         cursor.execute(drop_table_query)
    >         
    >         # 2. í…Œì´ë¸” ìƒì„±
    >         create_table_query = """
    >         CREATE TABLE django_schema.search_songs (
    >             no SERIAL PRIMARY KEY,
    >             song_title VARCHAR(255) NOT NULL,
    >             song_url VARCHAR(255) NOT NULL,
    >             thumbnail VARCHAR(255),
    >             platform VARCHAR(255) NOT NULL
    >         );
    >         """
    >         cursor.execute(create_table_query)
    >         logger.info(" search_songs _ ìƒˆ í…Œì´ë¸” ìƒì„± ì™„ë£Œ")
    >     
    >         
    >         # 3. search_youtube_video ë°ì´í„°ë¥¼ search_songsì— ì‚½ì…
    >         youtube_query = """
    >         INSERT INTO django_schema.search_songs (song_title, song_url, thumbnail, platform)
    >         SELECT 
    >             video_title AS song_title,
    >             video_id AS song_url,
    >             CONCAT('https://img.youtube.com/vi/', video_id, '/0.jpg') AS thumbnail,
    >             'youtube' AS platform
    >         FROM playlist_schema.search_youtube_video;
    >         """
    >         cursor.execute(youtube_query)
    >     
    >         # 4. spotify_recommend ë°ì´í„°ë¥¼ search_songsì— ì‚½ì…
    >         spotify_query = """
    >         INSERT INTO django_schema.search_songs (song_title, song_url, thumbnail, platform)
    >         SELECT 
    >             title AS song_title,
    >             link AS song_url,
    >             cover_image AS thumbnail,
    >             'spotify' AS platform
    >         FROM playlist_schema.spotify_recommend;
    >         """
    >         cursor.execute(spotify_query)
    >         logger.info(f" search songs : ë°ì´í„°ê°€ ì‚½ì… ë˜ì—ˆìŠµë‹ˆë‹¤.")
    >     
    >         return
    >     
    >     def load_data_to_db(search_video_df, recommendations_data):
    >         """ ë°ì´í„°ë² ì´ìŠ¤ì— ë°ì´í„° ë¡œë“œ """
    >         if search_video_df.empty:
    >             logger.warning("youtube ê²€ìƒ‰ _ í…Œì´ë¸”ì— ë¹ˆ í…Œì´ë¸”ì´ ìˆìŠµë‹ˆë‹¤.")
    >             return
    >         if not recommendations_data:
    >             logger.warning("spotify ì¶”ì²œê³¡ _ ë¡œë“œí•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
    >             return
    >     
    >         pg_hook = PostgresHook(postgres_conn_id='playlist')  # ì—°ê²° ID ì‚¬ìš©
    >         conn_tmp = pg_hook.get_connection(pg_hook.postgres_conn_id)
    >         # ì§ì ‘ psycopg2ë¡œ ì—°ê²°í•˜ê³  ì¸ì½”ë”©ì„ ì„¤ì •
    >         try:
    >             conn = psycopg2.connect(
    >                 host=conn_tmp.host,
    >                 database=conn_tmp.schema,
    >                 user=conn_tmp.login,
    >                 password=conn_tmp.password,
    >                 port=conn_tmp.port,
    >                 client_encoding='UTF8'  # ì¸ì½”ë”© ì„¤ì •
    >             )
    >             cursor = conn.cursor()
    >     
    >             # ê¸°ì¡´ search_youtube í…Œì´ë¸” ë“œë¡­
    >             logger.info("youtube ê²€ìƒ‰ _ search_youtube_video ê¸°ì¡´ í…Œì´ë¸” ì‚­ì œ ì¤‘...")
    >     
    >             cursor.execute("DROP TABLE IF EXISTS playlist_schema.search_youtube_video;")
    >     
    >             # ê¸°ì¡´ songs í…Œì´ë¸” ë“œë¡­
    >             logger.info("spotify ì¶”ì²œê³¡ _ ê¸°ì¡´ í…Œì´ë¸” ì‚­ì œ ì¤‘...")
    >             cursor.execute("DROP TABLE IF EXISTS playlist_schema.spotify_recommend")
    >     
    >             logger.info("youtube ê²€ìƒ‰ _ search_youtube_video ìƒˆ í…Œì´ë¸” ìƒì„± ì¤‘...")
    >             # search_youtube í…Œì´ë¸” ìƒì„± (noëŠ” SERIAL PKë¡œ ì„¤ì •)
    >             cursor.execute("""
    >                 CREATE TABLE IF NOT EXISTS playlist_schema.search_youtube_video (
    >                     no SERIAL PRIMARY KEY,
    >                     video_title VARCHAR(255),
    >                     video_id VARCHAR(255)
    >                 );
    >             """)
    >     
    >             logger.info("youtube ê²€ìƒ‰ _ search_youtube_video ìƒˆ í…Œì´ë¸” ìƒì„± ì™„ë£Œ")
    >     
    >             # songs í…Œì´ë¸” ìƒì„± (noëŠ” SERIAL PKë¡œ ì„¤ì •)
    >             logger.info("spotify ì¶”ì²œê³¡ _ ìƒˆ í…Œì´ë¸” ìƒì„± ì¤‘...")
    >             create_table_query = """
    >             CREATE TABLE playlist_schema.spotify_recommend (
    >                 no SERIAL PRIMARY KEY,
    >                 title VARCHAR(256),
    >                 link VARCHAR(256),
    >                 cover_image VARCHAR(256)
    >             )
    >             """
    >             cursor.execute(create_table_query)
    >             logger.info("spotify ì¶”ì²œê³¡ _ ìƒˆ í…Œì´ë¸” ìƒì„± ì™„ë£Œ")
    >     
    >             # youtube_songs ë°ì´í„°í”„ë ˆì„ì„ í…Œì´ë¸”ì— ì‚½ì…
    >             bulk_insert_table(cursor, conn, search_video_df, 'playlist_schema.search_youtube_video')
    >             logger.info("youtube ê²€ìƒ‰ _ search_youtube ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ë°ì´í„°ë² ì´ìŠ¤ì— ì‚½ì…ë˜ì—ˆìŠµë‹ˆë‹¤.")
    >     
    >             # ë°ì´í„°ë¥¼ songs í…Œì´ë¸”ì— ì‚½ì…
    >             for song in recommendations_data:
    >                 insert_query = """
    >                 INSERT INTO playlist_schema.spotify_recommend (title, link, cover_image)
    >                 VALUES (%s, %s, %s)
    >                 """
    >                 cursor.execute(insert_query, (song['title'], song['link'], song['cover_image']))
    >             logger.info("spotify ì¶”ì²œê³¡ _ ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ë°ì´í„°ë² ì´ìŠ¤ì— ì‚½ì…ë˜ì—ˆìŠµë‹ˆë‹¤.")
    >     
    >             #django_schema insert
    >             transform_schema(cursor)
    >     
    >             conn.commit()
    >     
    >         except Exception as e:
    >             # ì˜ˆì™¸ ë°œìƒ ì‹œ ë¡¤ë°±
    >             logger.error(f"ì¶”ì²œê³¡ _ ë°ì´í„° ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
    >             conn.rollback()
    >     
    >         finally:
    >             # ì»¤ì„œì™€ ì—°ê²° ë‹«ê¸°
    >             cursor.close()
    >             conn.close()
    >             logger.info("ì¶”ì²œê³¡ _ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
    >         return
    >     
    >     # Airflow DAG ì •ì˜
    >     default_args = {
    >         'owner': 'airflow',
    >         'retries': 1,
    >         'retry_delay': timedelta(minutes=5),
    >         'start_date': datetime(2023, 11, 22),  # ì›í•˜ëŠ” ì‹œì‘ ë‚ ì§œ ì„¤ì •
    >     }
    >     
    >     dag = DAG(
    >         'etl_dag_search_songs',  # DAG ì´ë¦„
    >         default_args=default_args,
    >         description='ETL for recommend songs',
    >         schedule_interval= None,  # ì¶”í›„ í´ë¦­ webhook ì´ë²¤íŠ¸ë¡œ êµì²´í•´ì•¼í•¨
    >         catchup = False,
    >     )
    >     
    >     # Airflow Task ì •ì˜
    >     def run_etl(**kwargs):
    >         # confì—ì„œ song_title ë°›ì•„ì˜¤ê¸°
    >         song_title = kwargs['dag_run'].conf.get('input_value')
    >         
    >         if song_title:
    >             song_title = song_title
    >             search_video_df, recommendations_data = extract_data_from_site(song_title)
    >             load_data_to_db(search_video_df, recommendations_data)
    >         else:
    >             logger.error("song_titleì´ confì—ì„œ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
    >     
    >     # DAG ì•ˆì—ì„œ Task ì—°ê²°
    >     etl_task = PythonOperator(
    >         task_id='etl_task_tracks',
    >         python_callable=run_etl,
    >         provide_context=True,  # dag_runì„ contextë¡œ ì œê³µ
    >         dag=dag,
    >     )
    >     
    >     etl_task
    >     
    >     ```
    >     
    > - [**`playlist_dag.py`**] `ê²€ìƒ‰ì–´ ê¸°ë°˜ Spotify ì¶”ì²œ ìƒìœ„ 10ê°œ playlist / ê²€ìƒ‰ì–´ ê¸°ë°˜ Youtube playlist ì¤‘ ìƒìœ„ 10ê°œ playlist (Django input trigger ê°±ì‹ )`
    >     
    >     ```python
    >     import os
    >     import spotipy
    >     from airflow.models import Variable
    >     from airflow import DAG
    >     from airflow.operators.python import PythonOperator
    >     from airflow.providers.postgres.hooks.postgres import PostgresHook
    >     from datetime import datetime, timedelta
    >     from youtube_class import YoutubeClient
    >     from spotify_class import SpotifyClient
    >     import psycopg2
    >     import pandas as pd
    >     from io import StringIO
    >     import csv
    >     import logging
    >     
    >     logging.basicConfig(
    >         level=logging.INFO,  # ë¡œê·¸ ë ˆë²¨ì„ INFOë¡œ ì„¤ì •
    >         format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    >     )
    >     logger = logging.getLogger(__name__)
    >     
    >     def extract_data_from_site(song_title):
    >         
    >         """spotifyì—ì„œ playlistë¥¼ ê°€ì§€ê³  ì˜¤ëŠ” í•¨ìˆ˜"""
    >         spotify_client = SpotifyClient()
    >         playlist_data = spotify_client.find_playlists_by_song(song_title)
    >         logger.info(f"spotify playlist _ ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤: {playlist_data}")
    >     
    >         """ youtubeì—ì„œ playlistë¥¼ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜ """
    >         youtube_client = YoutubeClient()
    >         search_playlist_df = youtube_client.search_youtube_playlist(song_title + " music")
    >         logger.info(f"youtube ê²€ìƒ‰ _ ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤: {search_playlist_df}")
    >     
    >         return search_playlist_df, playlist_data
    >     
    >     def bulk_insert_table(cursor, conn, df, table_name):
    >         """
    >         ë°ì´í„°í”„ë ˆì„ì„ PostgreSQL í…Œì´ë¸”ì— COPY ëª…ë ¹ìœ¼ë¡œ ë¹ ë¥´ê²Œ ì‚½ì….
    >         """
    >         # ë°ì´í„°í”„ë ˆì„ì„ CSV í˜•ì‹ìœ¼ë¡œ ë©”ëª¨ë¦¬ì— ì €ì¥
    >         buffer = StringIO()
    >         df.to_csv(buffer, index=False, header=False, quotechar='"', quoting=csv.QUOTE_ALL)
    >         buffer.seek(0)
    >     
    >         try:
    >             # COPY ëª…ë ¹ ì‹¤í–‰
    >             cursor.copy_expert(f"COPY {table_name} FROM STDIN WITH CSV", buffer)
    >             logger.info(f"youtube ê²€ìƒ‰ _ í…Œì´ë¸” {table_name}ì— ë°ì´í„° ì‚½ì… ì™„ë£Œ")
    >         except Exception as e:
    >             # ì—ëŸ¬ ë°œìƒ ì‹œ íŠ¸ëœì­ì…˜ ë¡¤ë°±
    >             conn.rollback()
    >             logger.error(f"youtube ê²€ìƒ‰ _ {table_name} ì‚½ì… ì˜¤ë¥˜: {e}")
    >         finally:
    >             buffer.close()
    >     
    >     def transform_schema(cursor):
    >         # search_playlist
    >         # 1. í…Œì´ë¸” ì‚­ì œ
    >         drop_table_query = "DROP TABLE IF EXISTS django_schema.search_playlist;"
    >         cursor.execute(drop_table_query)
    >     
    >         # 2. í…Œì´ë¸” ìƒì„±
    >         create_table_query = """
    >         CREATE TABLE django_schema.search_playlist (
    >             no SERIAL PRIMARY KEY,
    >             playlist_title VARCHAR(255) NOT NULL,
    >             playlist_url VARCHAR(255) NOT NULL,
    >             thumbnail VARCHAR(255),
    >             platform VARCHAR(255) NOT NULL
    >         );
    >         """
    >         cursor.execute(create_table_query)
    >     
    >         # 3. search_youtube_video ë°ì´í„°ë¥¼ search_songsì— ì‚½ì…
    >         youtube_query = """
    >         INSERT INTO django_schema.search_playlist (playlist_title, playlist_url, thumbnail, platform)
    >         SELECT 
    >             playlist_title AS playlist_title,
    >             playlist_id AS playlist_url,
    >             playlist_thumbnail AS thumbnail,
    >             'youtube' AS platform
    >         FROM playlist_schema.search_youtube_playlist;
    >         """
    >         cursor.execute(youtube_query)
    >     
    >         # 4. spotify_recommend ë°ì´í„°ë¥¼ search_songsì— ì‚½ì…
    >         spotify_query = """
    >         INSERT INTO django_schema.search_playlist (playlist_title, playlist_url, thumbnail, platform)
    >         SELECT 
    >             title AS playlist_title,
    >             link AS playlist_url,
    >             cover_image AS thumbnail,
    >             'spotify' AS platform
    >         FROM playlist_schema.spotify_playlist;
    >         """
    >         cursor.execute(spotify_query)
    >         return
    >     
    >     def load_data_to_db(search_playlist_df, playlist_data):
    >         """ ë°ì´í„°ë² ì´ìŠ¤ì— ë°ì´í„° ë¡œë“œ """
    >         if search_playlist_df.empty:
    >             logger.warning("youtube ê²€ìƒ‰ _ í…Œì´ë¸”ì— ë¹ˆ í…Œì´ë¸”ì´ ìˆìŠµë‹ˆë‹¤.")
    >             return
    >         if not playlist_data:
    >             logger.warning("spotify playlist _ ë¡œë“œí•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
    >             return
    >     
    >         pg_hook = PostgresHook(postgres_conn_id='playlist')  # ì—°ê²° ID ì‚¬ìš©
    >         conn_tmp = pg_hook.get_connection(pg_hook.postgres_conn_id)
    >         # ì§ì ‘ psycopg2ë¡œ ì—°ê²°í•˜ê³  ì¸ì½”ë”©ì„ ì„¤ì •
    >         try:
    >             conn = psycopg2.connect(
    >                 host=conn_tmp.host,
    >                 database=conn_tmp.schema,
    >                 user=conn_tmp.login,
    >                 password=conn_tmp.password,
    >                 port=conn_tmp.port,
    >                 client_encoding='UTF8'  # ì¸ì½”ë”© ì„¤ì •
    >             )
    >             cursor = conn.cursor()
    >     
    >             # ê¸°ì¡´ search_youtube í…Œì´ë¸” ë“œë¡­
    >             logger.info("youtube ê²€ìƒ‰ _ search_youtube ê¸°ì¡´ í…Œì´ë¸” ì‚­ì œ ì¤‘...")
    >             cursor.execute("DROP TABLE IF EXISTS playlist_schema.search_youtube_playlist;")
    >     
    >             # ê¸°ì¡´ playlists í…Œì´ë¸” ë“œë¡­
    >             logger.info("spotify playlist _ ê¸°ì¡´ í…Œì´ë¸” ì‚­ì œ ì¤‘...")
    >             cursor.execute("DROP TABLE IF EXISTS playlist_schema.spotify_playlist")
    >     
    >             logger.info("youtube ê²€ìƒ‰ _ search_youtube_playlist ìƒˆ í…Œì´ë¸” ìƒì„± ì¤‘...")
    >             # search_youtube í…Œì´ë¸” ìƒì„± (noëŠ” SERIAL PKë¡œ ì„¤ì •)
    >             cursor.execute("""
    >                 CREATE TABLE IF NOT EXISTS playlist_schema.search_youtube_playlist (
    >                     no SERIAL PRIMARY KEY,
    >                     playlist_title VARCHAR(255),
    >                     playlist_id VARCHAR(255),
    >                     playlist_thumbnail VARCHAR(255)
    >                 );
    >             """)
    >             logger.info("youtube ê²€ìƒ‰ _ search_youtube_playlist ìƒˆ í…Œì´ë¸” ìƒì„± ì™„ë£Œ")
    >             
    >             # playlists í…Œì´ë¸” ìƒì„± (noëŠ” SERIAL PKë¡œ ì„¤ì •)
    >             logger.info("spotify playlist _ ìƒˆ í…Œì´ë¸” ìƒì„± ì¤‘...")
    >             cursor.execute("""
    >             CREATE TABLE playlist_schema.spotify_playlist (
    >                 no SERIAL PRIMARY KEY,
    >                 title VARCHAR(256),
    >                 link VARCHAR(256),
    >                 cover_image VARCHAR(256)
    >                 );
    >             """)
    >             logger.info("spotify playlist _ ìƒˆ í…Œì´ë¸” ìƒì„± ì™„ë£Œ")
    >     
    >             # youtube ë°ì´í„°í”„ë ˆì„ì„ í…Œì´ë¸”ì— ì‚½ì…
    >             bulk_insert_table(cursor, conn, search_playlist_df, 'playlist_schema.search_youtube_playlist')
    >             logger.info("youtube ê²€ìƒ‰ _ search_youtube_playlist ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ë°ì´í„°ë² ì´ìŠ¤ì— ì‚½ì…ë˜ì—ˆìŠµë‹ˆë‹¤.")
    >             
    >             # ë°ì´í„°ë¥¼ playlists í…Œì´ë¸”ì— ì‚½ì…
    >             for playlist in playlist_data:
    >                 insert_query = """
    >                 INSERT INTO playlist_schema.spotify_playlist (title, link, cover_image)
    >                 VALUES (%s, %s, %s)
    >                 """
    >                 cursor.execute(insert_query, (playlist['title'], playlist['link'], playlist['cover_image']))
    >             logger.info("spotify playlist _ ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ë°ì´í„°ë² ì´ìŠ¤ì— ì‚½ì…ë˜ì—ˆìŠµë‹ˆë‹¤.")
    >     
    >             #django schema insert
    >             transform_schema(cursor)
    >     
    >             conn.commit()
    >             
    >         except Exception as e:
    >             # ì˜ˆì™¸ ë°œìƒ ì‹œ ë¡¤ë°±
    >             logger.error(f"playlist _ ë°ì´í„° ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
    >             conn.rollback()
    >     
    >         finally:
    >             # ì»¤ì„œì™€ ì—°ê²° ë‹«ê¸°
    >             cursor.close()
    >             conn.close()
    >             logger.info("playlist _ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
    >         return
    >     
    >     # Airflow DAG ì •ì˜
    >     default_args = {
    >         'owner': 'airflow',
    >         'retries': 1,
    >         'retry_delay': timedelta(minutes=5),
    >         'start_date': datetime(2023, 11, 22),  # ì›í•˜ëŠ” ì‹œì‘ ë‚ ì§œ ì„¤ì •
    >     }
    >     
    >     dag = DAG(
    >         'etl_dag_playlist',  # DAG ì´ë¦„
    >         default_args=default_args,
    >         description='ETL for recommend Playlists',
    >         schedule_interval=None,  # ì¶”í›„ í´ë¦­ webhook ì´ë²¤íŠ¸ë¡œ êµì²´í•´ì•¼í•¨
    >         catchup = False,
    >     )
    >     
    >     # Airflow Task ì •ì˜
    >     def run_etl(**kwargs):
    >         # confì—ì„œ song_title ë°›ì•„ì˜¤ê¸°
    >         song_title = kwargs['dag_run'].conf.get('input_value')
    >         
    >         if song_title:
    >             song_title = song_title
    >             search_playlist_df, playlist_data = extract_data_from_site(song_title)
    >             load_data_to_db(search_playlist_df, playlist_data)
    >         else:
    >             logger.error("song_titleì´ confì—ì„œ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
    >     
    >     # DAG ì•ˆì—ì„œ Task ì—°ê²°
    >     etl_task = PythonOperator(
    >         task_id='etl_task_playlist',
    >         python_callable=run_etl,
    >         provide_context=True,  # dag_runì„ contextë¡œ ì œê³µ
    >         dag=dag,
    >     )
    >     
    >     etl_task
    >     ```
    >     
    > - [**`spotify_class.py`**] `spotify api ì‚¬ìš©ì„ ìœ„í•œ class`
    >     
    >     ```python
    >     import os
    >     import spotipy
    >     from airflow.models import Variable
    >     from spotipy.oauth2 import SpotifyClientCredentials
    >     from airflow import DAG
    >     from airflow.operators.python import PythonOperator
    >     from airflow.providers.postgres.hooks.postgres import PostgresHook
    >     from datetime import datetime, timedelta
    >     import requests
    >     import base64
    >     
    >     class SpotifyClient:
    >         def __init__(self):
    >             """ í™˜ê²½ ë³€ìˆ˜ ê°€ì ¸ì˜¤ê¸° """
    >             client_id = Variable.get("CLIENT_ID")
    >             client_secret = Variable.get("CLIENT_SECRET")
    >     
    >             # Spotipy initialization
    >             self.scope = "playlist-read-private playlist-read-collaborative"
    >             self.sp = spotipy.Spotify(
    >                 auth_manager=SpotifyClientCredentials(
    >                     client_id=client_id,
    >                     client_secret=client_secret,
    >                 )
    >             )
    >             
    >         def get_recommendations(self, song_title):
    >             """ ì¶”ì²œê³¡ì„ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜ """
    >             # ë…¸ë˜ ê²€ìƒ‰
    >             results = self.sp.search(q=song_title, type='track', limit=1)
    >             
    >             if not results['tracks']['items']:
    >                 print("No track found with that name.")
    >                 return []
    >             
    >             track = results['tracks']['items'][0]
    >             print(f"Found track: {track['name']} by {track['artists'][0]['name']}")
    >     
    >             # ì¶”ì²œ ê³¡ ë°›ê¸°
    >             recommendations = self.sp.recommendations(seed_tracks=[track['id']], limit=20)
    >             
    >             recommendations_data = []
    >             youtube_recommendations_data = []
    >             for rec in recommendations['tracks']:
    >                 album_cover_url = rec['album']['images'][0]['url']
    >                 song_info = {
    >                     "title": rec['name'],
    >                     "link": rec['external_urls']['spotify'],
    >                     "cover_image": album_cover_url
    >                 }
    >                 if len(recommendations_data) < 10:
    >                     recommendations_data.append(song_info)
    >                 else:
    >                     youtube_recommendations_data.append(rec['name'])
    >     
    >             return recommendations_data, youtube_recommendations_data
    >     
    >         def find_playlists_by_song(self, song_title):
    >             """ ë…¸ë˜ ì œëª©ì„ ì…ë ¥ë°›ì•„ í•´ë‹¹ ë…¸ë˜ê°€ í¬í•¨ëœ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ë¥¼ ì°¾ëŠ” í•¨ìˆ˜ """
    >             # ë…¸ë˜ ê²€ìƒ‰
    >             results = self.sp.search(q=song_title, type='track', limit=10)
    >             
    >             if not results['tracks']['items']:
    >                 print("No track found with that name.")
    >                 return []
    >             
    >             track = results['tracks']['items'][0]
    >             print(f"Found track: {track['name']} by {track['artists'][0]['name']}")
    >     
    >             # í•´ë‹¹ íŠ¸ë™ì„ í¬í•¨í•œ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ê²€ìƒ‰
    >             playlists = self.sp.search(q=track['name'], type='playlist', limit=10)
    >             
    >             if not playlists['playlists']['items']:
    >                 print("No playlists found containing this song.")
    >                 return []
    >             
    >             playlist_data = []
    >             for playlist in playlists['playlists']['items']:
    >                 playlist_name = playlist['name']
    >                 playlist_url = playlist['external_urls']['spotify']
    >                 playlist_cover_url = playlist['images'][0]['url'] if playlist['images'] else 'No image available'
    >                 playlist_info = {
    >                     "title": playlist_name,
    >                     "link": playlist_url,
    >                     "cover_image": playlist_cover_url
    >                 }
    >                 playlist_data.append(playlist_info)
    >                 
    >             return playlist_data
    >         
    >         def get_top_10_playlists(self):
    >             # 'Top'ì´ë¼ëŠ” í‚¤ì›Œë“œë¡œ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ê²€ìƒ‰
    >             results = self.sp.search(q="Top", type='playlist', limit=10)
    >     
    >             if not results['playlists']['items']:
    >                 print("No playlists found.")
    >                 return
    >     
    >             print(f"Top 10 playlists:")
    >             today_playlists_data = []
    >             for idx, playlist in enumerate(results['playlists']['items'], 1):
    >                 playlist_name = playlist['name']
    >                 playlist_url = playlist['external_urls']['spotify']
    >                 playlist_cover_url = playlist['images'][0]['url'] if playlist['images'] else 'No image available'
    >                 playlist_info = {
    >                     "title": playlist_name,
    >                     "link": playlist_url,
    >                     "cover_image": playlist_cover_url
    >                 }
    >                 today_playlists_data.append(playlist_info)
    >                 
    >             return today_playlists_data
    >         
    >         def get_top_10_tracks_from_playlist(self):
    >             # 'Global Top 50' í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ID
    >             global_top_50_playlist_id = '37i9dQZEVXbMDoHDwVN2tF'  # ì´ IDëŠ” Spotify Global Top 50 í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ì˜ IDì…ë‹ˆë‹¤.
    >             
    >             # í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ì—ì„œ íŠ¸ë™ ê°€ì ¸ì˜¤ê¸°
    >             results = self.sp.playlist_tracks(global_top_50_playlist_id, limit=10)
    >     
    >             if not results['items']:
    >                 print("No tracks found in the playlist.")
    >                 return
    >     
    >             top_songs = []
    >             for item in results['items']:
    >                 track = item['track']  # íŠ¸ë™ ì •ë³´ëŠ” 'track' í‚¤ ì•„ë˜ì— ì¡´ì¬í•©ë‹ˆë‹¤.
    >                 album_cover_url = track['album']['images'][0]['url'] if track['album']['images'] else 'No image available'
    >                 song_info = {
    >                     "title": track['name'],
    >                     "link": track['external_urls']['spotify'],
    >                     "cover_image": album_cover_url
    >                 }
    >                 top_songs.append(song_info)
    >     
    >             return top_songs
    >     ```
    >     
    > - [**`youtube_class.py`**] `youtube api ì‚¬ìš©ì„ ìœ„í•œ class`
    >     
    >     ```python
    >     import requests
    >     import pandas as pd
    >     from airflow.models import Variable
    >     from spotipy.oauth2 import SpotifyClientCredentials
    >     from airflow import DAG
    >     from airflow.operators.python import PythonOperator
    >     from airflow.providers.postgres.hooks.postgres import PostgresHook
    >     import html
    >     
    >     # YouTube Data API ì„¤ì •
    >     
    >     class YoutubeClient:
    >         def __init__(self):
    >             self.API_KEY = Variable.get("API_KEY") # airflow Var
    >             self.SEARCH_URL = Variable.get("SEARCH_URL")
    >             self.BASE_URL = Variable.get("BASE_URL")
    >     
    >         def search_youtube_playlist(self, song_title, max_results=10):
    >             params = {
    >                 'key': self.API_KEY,
    >                 'q': song_title,
    >                 'type': 'playlist',
    >                 'part': 'snippet',
    >                 'maxResults': max_results
    >             }
    >             response = requests.get(self.SEARCH_URL, params=params)
    >     
    >             if response.status_code != 200:
    >                 print(f"Error: {response.status_code}, {response.text}")
    >                 return pd.DataFrame()  # ë¹ˆ DataFrame ë°˜í™˜
    >     
    >             data = response.json()
    >             playlists = []
    >             for idx, item in enumerate(data.get('items', []), 1):
    >                 title = item['snippet']['title']
    >                 title = html.unescape(title)
    >                 playlist_id = item['id']['playlistId']
    >                 thumbnails = item["snippet"].get("thumbnails", {})
    >                 thumbnail_url = thumbnails.get("medium", {}).get("url", "")  # ì¸ë„¤ì¼ URL ê°€ì ¸ì˜¤ê¸°
    >                 playlists.append({
    >                     "no": idx,
    >                     "playlist_title": item["snippet"]["title"],
    >                     "playlist_id": playlist_id,
    >                     'playlist_thumbnail': thumbnail_url
    >                 })
    >     
    >             return pd.DataFrame(playlists)
    >         
    >         def search_youtube(self, youtube_recommendations_data, max_results=10):
    >             """
    >             íŠ¹ì • ë…¸ë˜ ì œëª©ìœ¼ë¡œ ë™ì˜ìƒê³¼ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ë¥¼ 
    >             10ê°œì”© ê²€ìƒ‰í•˜ì—¬ DataFrameìœ¼ë¡œ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜.
    >             """
    >             #spotify ë…¸ë˜ ë°›ì•„ì˜¤ê¸°
    >             videos = []
    >             for search_keyword in youtube_recommendations_data:
    >                 #spotify ë…¸ë˜ ê¸°ì¤€ search
    >                 params = {
    >                     'key': self.API_KEY,
    >                     'q': search_keyword,
    >                     'type': 'video',
    >                     'part': 'snippet',
    >                     'maxResults': 1
    >                 }
    >                 response = requests.get(self.SEARCH_URL, params=params)
    >     
    >                 if response.status_code != 200:
    >                     print(f"Error: {response.status_code}, {response.text}")
    >                     return pd.DataFrame()  # ë¹ˆ DataFrame ë°˜í™˜
    >                 
    >                 data = response.json()
    >                 
    >                 title = data.get('items')[0]['snippet']['title']
    >                 title = html.unescape(title)
    >                 video_id = data.get('items')[0]['id']['videoId']
    >                 idx = len(videos) + 1
    >                 videos.append({'no': idx, 'video_title': title, 'video_id': video_id})
    >     
    >             return pd.DataFrame(videos)
    >     
    >         def daily_youtube(self):
    >             # 1. 'ìŒì•…' ì¹´í…Œê³ ë¦¬ì˜ ì¸ê¸° ë¹„ë””ì˜¤ ê°€ì ¸ì˜¤ê¸°
    >             url = f"{self.BASE_URL}/videos"
    >             params = {
    >                 "part": "snippet,statistics",
    >                 "chart": "mostPopular",
    >                 "videoCategoryId": "10",  # ìŒì•… ì¹´í…Œê³ ë¦¬
    >                 "maxResults": 10,  # Top 10
    >                 "key": self.API_KEY,
    >             }
    >     
    >             response = requests.get(url, params=params)
    >     
    >             if response.status_code == 200:
    >                 data = response.json()
    >                 videos = data.get("items", [])
    >                 video_list = []
    >     
    >                 # 2. ë¹„ë””ì˜¤ ì •ë³´ë¥¼ ì •ë¦¬
    >                 for idx, video in enumerate(videos, 1):
    >                     video_id = video["id"]
    >                     # video_idê°€ ë¬¸ìì—´ì¸ì§€ í™•ì¸
    >                     if isinstance(video_id, str):
    >                         video_id = video["id"]  # idê°€ ë¬¸ìì—´ì´ë¼ë©´ ë°”ë¡œ ì‚¬ìš©
    >                     elif isinstance(video_id, dict):
    >                         video_id = video_id.get("videoId", "")  # ë”•ì…”ë„ˆë¦¬ì—ì„œ videoId ì¶”ì¶œ
    >                     video_list.append({
    >                         "no": idx,
    >                         "video_title": video["snippet"]["title"],
    >                         "video_id": video_id
    >                     })
    >     
    >             else:
    >                 print(f"API ìš”ì²­ ì‹¤íŒ¨: {response.status_code}, {response.text}")
    >                 return []
    >     
    >             # 1. 'ìŒì•…' ì¹´í…Œê³ ë¦¬ì˜ ì¸ê¸° í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
    >             url = f"{self.BASE_URL}/search"
    >             params = {
    >                 "part": "snippet",
    >                 "type": "playlist",  # í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ë§Œ ê²€ìƒ‰
    >                 "maxResults": 10,  # Top 10
    >                 "key": self.API_KEY,
    >             }
    >     
    >             response = requests.get(url, params=params)
    >     
    >             if response.status_code == 200:
    >                 data = response.json()
    >                 playlists = data.get("items", [])
    >                 playlist_list = []
    >     
    >                 # 2. í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ì •ë³´ë¥¼ ì •ë¦¬
    >                 for idx, playlist in enumerate(playlists, 1):
    >                     playlist_id = playlist["id"].get("playlistId", "")
    >                     thumbnails = playlist["snippet"].get("thumbnails", {})
    >                     thumbnail_url = thumbnails.get("medium", {}).get("url", "")  # ì¸ë„¤ì¼ URL ê°€ì ¸ì˜¤ê¸°
    >     
    >                     playlist_list.append({
    >                         "no": idx,
    >                         "playlist_title": playlist["snippet"]["title"],
    >                         "playlist_id": playlist_id,
    >                         'playlist_thumbnail': thumbnail_url
    >                     })
    >     
    >                 return pd.DataFrame(video_list), pd.DataFrame(playlist_list)
    >             else:
    >                 print(f"API ìš”ì²­ ì‹¤íŒ¨: {response.status_code}, {response.text}")
    >                 return []
    >     
    >     ```
    >     
    
    ğŸ“‹**ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì • ë° ì ì¬**
    
    **[Schema] playlist_schema**
    
    > **`ğŸ“ˆ video, track, playlist ë°ì´í„° ì ì¬`**
    > 
    > - [**`spotify_today_tracks`**] `spotify ì˜¤ëŠ˜ì˜ Top 10 track`
    >     
    >     ```sql
    >     CREATE TABLE playlist_schema.spotify_today_tracks (
    >     	no	serial	NOT NULL,
    >     	title	VARCHAR(255)	NOT NULL,
    >     	link	VARCHAR(255)	NOT NULL,
    >     	cover_image	VARCHAR(255)	NOT NULL
    >     );
    >     ```
    >     
    > - [**`spotify_today_playlists`**] `spotify ì˜¤ëŠ˜ì˜ top playlist`
    >     
    >     ```sql
    >     CREATE TABLE playlist_schema.spotify_today_playlists (
    >     	no	serial	NOT NULL,
    >     	title	VARCHAR(255)	NOT NULL,
    >     	link	VARCHAR(255)	NOT NULL,
    >     	cover_image	VARCHAR(255)	NOT NULL
    >     );
    >     ```
    >     
    > - [**`spotify_playlist`**] `ê²€ìƒ‰ì–´ ê¸°ì¤€ spotify ì¶”ì²œ playlist`
    >     
    >     ```sql
    >     CREATE TABLE playlist_schema.spotify_playlist (
    >     	no	serial	NOT NULL,
    >     	title	VARCHAR(255)	NOT NULL,
    >     	link	VARCHAR(255)	NOT NULL,
    >     	cover_image	VARCHAR(255)	NOT NULL
    >     );
    >     ```
    >     
    > - [**`spotify_recommend`**] `ê²€ìƒ‰ì–´ ê¸°ì¤€ spotify ì¶”ì²œ track`
    >     
    >     ```sql
    >     CREATE TABLE playlist_schema.spotify_recommend (
    >     	no	serial	NOT NULL,
    >     	title	VARCHAR(255)	NOT NULL,
    >     	cover_image	VARCHAR(255)	NOT NULL
    >     );
    >     ```
    >     
    > - [**`daily_youtube_video`**] `youtube ì˜¤ëŠ˜ì˜ top video`
    >     
    >     ```sql
    >     CREATE TABLE playlist_schema.daily_youtube_video (
    >     	no	serial	NOT NULL,
    >     	video_title	VARCHAR(255)	NOT NULL,
    >     	video_id	VARCHAR(255)	NOT NULL
    >     );
    >     ```
    >     
    > - [**`search_youtube_playlist`**] `ê²€ìƒ‰ì–´ ê¸°ì¤€ youtube ì¶”ì²œ playlist`
    >     
    >     ```sql
    >     CREATE TABLE playlist_schema.search_youtube_playlist (
    >     	no	serial	NOT NULL,
    >     	playlist_title	VARCHAR(255)	NOT NULL,
    >     	playlist_id	VARCHAR(255)	NOT NULL,
    >     	playlist_thumbnail	VARCHAR(255)	NOT NULL
    >     );
    >     ```
    >     
    > - [**`search_youtube_video`**] `ê²€ìƒ‰ì–´ ê¸°ì¤€ youtube ì¶”ì²œ video`
    >     
    >     ```sql
    >     CREATE TABLE playlist_schema.search_youtube_video (
    >     	no	serial	NOT NULL,
    >     	video_title	VARCHAR(255)	NOT NULL,
    >     	video_id	VARCHAR(255)	NOT NULL
    >     );
    >     ```
    >     
    
    **[Schema] django_schema**
    
    > **`ğŸ“‰ Production DB`**
    > 
    > - [**`search_songs`**] `ê²€ìƒ‰ì–´ ê¸°ì¤€ spotify ì¶”ì²œ track ë° youtube ì¶”ì²œ video í†µí•©`
    >     
    >     ```sql
    >     CREATE TABLE django_schema.search_songs (
    >     	no	serial	NOT NULL,
    >     	song_title	VARCHAR(255)	NOT NULL,
    >     	song_url	VARCHAR(255)	NOT NULL,
    >     	thumbnail	VARCHAR(255)	NOT NULL,
    >     	platform	ENUM	NOT NULL
    >     );
    >     ```
    >     
    > - [**`search_playlist`**] `ê²€ìƒ‰ì–´ ê¸°ì¤€ spotify ë° youtube ì¶”ì²œ playlist í†µí•©`
    >     
    >     ```sql
    >     CREATE TABLE django_schema.search_playlist (
    >     	no	serial	NOT NULL,
    >     	playlist_title	VARCHAR(255)	NOT NULL,
    >     	playlist_url	VARCHAR(255)	NOT NULL,
    >     	thumbnail	VARCHAR(255)	NOT NULL,
    >     	platform	ENUM	NOT NULL
    >     );
    >     ```
    >     
    > - [**`daily_songs`**] `spotify ì˜¤ëŠ˜ì˜ top 10 ë° youtube ì˜¤ëŠ˜ì˜ top video í†µí•©`
    >     
    >     ```sql
    >     CREATE TABLE django_schema.daily_songs (
    >     	no	serial	NOT NULL,
    >     	song_title	VARCHAR(255)	NOT NULL,
    >     	song_url	VARCHAR(255)	NOT NULL,
    >     	thumbnail	VARCHAR(255)	NOT NULL,
    >     	platform	ENUM	NOT NULL
    >     );
    >     ```
    >     
    > - [**`daily_playlists`**] `spotify ë° youtube ì˜¤ëŠ˜ì˜ top playlist í†µí•©`
    >     
    >     ```sql
    >     CREATE TABLE django_schema.daily_playlists (
    >     	no	serial	NOT NULL,
    >     	playlist_title	VARCHAR(255)	NOT NULL,
    >     	playlist_url	VARCHAR(255)	NOT NULL,
    >     	thumbnail	VARCHAR(255)	NOT NULL,
    >     	platform	ENUM	NOT NULL
    >     );
    >     ```
    >     
- **Step3. ë°ì´í„° ì‹œê°í™” ë° Django (Web UI)**
    
    **ğŸ“Š ì˜¤ëŠ˜ì˜ Youtube, Spotify ì¶”ì²œ ê³¡ ë° í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ì œê³µ**
    
    **ğŸ“Š ë…¸ë˜ ê²€ìƒ‰ ê¸°ë°˜ì˜ Youtube, Spotifiy ì¶”ì²œ ê³¡ ë° í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ì œê³µ**
    
    **ë°±ì—”ë“œ (Model, View)**
    
    > **`ğŸ“‘ Model`**
    > 
    > - [**`models.py`**]
    >     
    >     ```python
    >     # í”Œë«í¼ ì„ íƒì§€ ENUM ì •ì˜
    >     class PlatformEnum(models.TextChoices):
    >     YOUTUBE = 'youtube', 'YouTube'
    >     SPOTIFY = 'spotify', 'Spotify'
    >     
    >     # DailySongs ëª¨ë¸
    >     class DailySongs(models.Model):
    >     no = models.AutoField(primary_key=True)
    >     song_title = models.CharField(max_length=255, verbose_name="Song Title")
    >     song_url = models.URLField(max_length=255, verbose_name="Song URL")
    >     thumbnail = models.URLField(max_length=255, null=True, blank=True, verbose_name="Thumbnail")
    >     platform = models.CharField(
    >     max_length=10,
    >     choices=PlatformEnum.choices,
    >     verbose_name="Platform",
    >     )
    >     
    >     class Meta:
    >         db_table = 'daily_songs'
    >         verbose_name = 'Daily Song'
    >         verbose_name_plural = 'Daily Songs'
    >     
    >     # DailyPlaylists ëª¨ë¸
    >     class DailyPlaylists(models.Model):
    >     no = models.AutoField(primary_key=True)  # ê¸°ë³¸ í‚¤ë¥¼ 'no'ë¡œ ì„¤ì •
    >     playlist_title = models.CharField(max_length=252, verbose_name="Playlist Title")
    >     playlist_url = models.URLField(max_length=255, verbose_name="Playlist URL")
    >     thumbnail = models.URLField(max_length=255, null=True, blank=True, verbose_name="Thumbnail")
    >     platform = models.CharField(
    >     max_length=10,
    >     choices=PlatformEnum.choices,
    >     verbose_name="Platform",
    >     )
    >     class Meta:
    >         db_table = 'daily_playlists'
    >         verbose_name = 'Daily Playlist'
    >         verbose_name_plural = 'Daily Playlists'
    >     
    >     # SearchSongs ëª¨ë¸
    >     class SearchSongs(models.Model):
    >     no = models.AutoField(primary_key=True)  # ê¸°ë³¸ í‚¤ë¥¼ 'no'ë¡œ ì„¤ì •
    >     song_title = models.CharField(max_length=255, verbose_name="Song Title")
    >     song_url = models.URLField(max_length=255, verbose_name="Song URL")
    >     thumbnail = models.URLField(max_length=255, null=True, blank=True, verbose_name="Thumbnail")
    >     platform = models.CharField(
    >     max_length=10,
    >     choices=PlatformEnum.choices,
    >     verbose_name="Platform",
    >     )
    >     class Meta:
    >         db_table = 'search_songs'
    >         verbose_name = 'Search Song'
    >         verbose_name_plural = 'Search Songs'
    >     
    >     # SearchPlaylist ëª¨ë¸
    >     class SearchPlaylist(models.Model):
    >     no = models.AutoField(primary_key=True)  # ê¸°ë³¸ í‚¤ë¥¼ 'no'ë¡œ ì„¤ì •
    >     playlist_title = models.CharField(max_length=252, verbose_name="Playlist Title")
    >     playlist_url = models.URLField(max_length=255, verbose_name="Playlist URL")
    >     thumbnail = models.URLField(max_length=255, null=True, blank=True, verbose_name="Thumbnail")
    >     platform = models.CharField(
    >     max_length=10,
    >     choices=PlatformEnum.choices,
    >     verbose_name="Platform",
    >     )
    >     
    >     class Meta:
    >         db_table = 'search_playlist'
    >         verbose_name = 'Search Playlist'
    >         verbose_name_plural = 'Search Playlists'
    >     ```
    >     
    > 
    >         `PostgreSQL db ëª¨ë¸ë§ ë° ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜`
    > 
    > **`ğŸ“‘ View`**
    > 
    > - [**`views.py`**]
    >     
    >     ```python
    >     from django.shortcuts import render, redirect
    >     from django.http import HttpResponse, JsonResponse
    >     from django.views.decorators.csrf import csrf_exempt
    >     from .models import DailySongs, DailyPlaylists, SearchSongs, SearchPlaylist
    >     import time
    >     
    >     def index(request):
    >         daily_songs = DailySongs.objects.all()
    >         daily_playlists = DailyPlaylists.objects.all()
    >     
    >         print(f"Daily Songs count: {daily_songs.count()}")
    >         print(f"Daily Playlists count: {daily_playlists.count()}")
    >     
    >         for song in daily_songs:
    >             print(f"Song: {song.song_title}, URL: {song.song_url}")
    >     
    >         for playlist in daily_playlists:
    >             playlist.playlist_url = playlist.playlist_url.replace("playlist", "embed/playlist")
    >     
    >         context = {
    >             'daily_songs': daily_songs,
    >             'daily_playlists': daily_playlists,
    >         }
    >         return render(request, 'search/index.html', context)
    >     
    >     import requests
    >     from requests.auth import HTTPBasicAuth
    >     
    >     @csrf_exempt
    >     def trigger_airflow_dag(request):
    >         if request.method == "POST":
    >             input_value = request.POST.get("input_value")
    >             platform = request.POST.get("platform")
    >     
    >             if not input_value:
    >                 return JsonResponse({"error": "ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!"}, status=400)
    >             
    >             if not platform:
    >                 return JsonResponse({"error": "ê²€ìƒ‰ í”Œë«í¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”!"}, status=400)
    >     
    >             # ì„¸ì…˜ì— ì €ì¥
    >             request.session['platform'] = platform
    >             request.session['input_value'] = input_value
    >     
    >             # airflow_url = "http://airflow_007-airflow-webserver:8080/api/v1/dags/etl_dag_search_songs/dagRuns"
    >             # airflow_url_playlist = "http://airflow_007-airflow-webserver:8080/api/v1/dags/etl_dag_playlist/dagRuns"
    >             airflow_url = "http://localhost:8080/api/v1/dags/example_trigger_dag/dagRuns"
    >             username = 'airflow'
    >             password = 'airflow'
    >     
    >             payload = {
    >                 "conf": {"input_value": input_value}
    >             }
    >     
    >             headers = {
    >                 'Content-Type': 'application/json',
    >                 'Accept': 'application/json',
    >             }
    >     
    >             try:
    >                 # response = requests.post(airflow_url, json=payload, headers=headers, auth=HTTPBasicAuth(username, password))
    >                 # response_play = requests.post(airflow_url_playlist, json=payload, headers=headers, auth=HTTPBasicAuth(username, password))
    >                 response = requests.post(airflow_url, json=payload, headers=headers, auth=HTTPBasicAuth(username, password))
    >                 if response.status_code == 200 : #and response_play.status_code == 200:
    >                     time.sleep(5)
    >                     # íŠ¸ë¦¬ê±° ì„±ê³µ í›„ ê²°ê³¼ í˜ì´ì§€ë¡œ ë¦¬ë””ë ‰ì…˜
    >                     return redirect('result')  # 'result'ëŠ” ê²°ê³¼ í˜ì´ì§€ì˜ URL ì´ë¦„
    >                 else:
    >                     return JsonResponse({"error": response.json()}, status=response.status_code)
    >             except Exception as e:
    >                 return JsonResponse({"error": str(e)}, status=500)
    >     
    >         return JsonResponse({"error": "Invalid request method"}, status=405)
    >     
    >     def result(request):    
    >         # ì„¸ì…˜ì—ì„œ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    >         platform = request.session.get('platform', None)
    >         input_value = request.session.get('input_value', None)
    >     
    >         # ëª¨ë“  ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
    >         search_songs = SearchSongs.objects.all()
    >         search_playlists = SearchPlaylist.objects.all()
    >     
    >         # Spotify URL ë³€í™˜
    >         for song in search_songs:
    >             if song.platform == "spotify" and "track" in song.song_url:
    >                 song.transformed_url = song.song_url.replace("track", "embed/track")
    >             else:
    >                 song.transformed_url = song.song_url
    >     
    >         for playlist in search_playlists:
    >             if playlist.platform == "spotify" and "playlist" in playlist.playlist_url:
    >                 playlist.playlist_url = playlist.playlist_url.replace("playlist", "embed/playlist")
    >     
    >         # í…œí”Œë¦¿ìœ¼ë¡œ ë°ì´í„° ì „ë‹¬
    >         context = {
    >             'search_songs': search_songs,
    >             'search_playlists': search_playlists,
    >             'platform': platform,  # í”Œë«í¼ ì •ë³´ ì „ë‹¬
    >             'input_value': input_value,
    >         }
    >         return render(request, 'search/result.html', context)
    >     ```
    >     
    > 
    >          `DBì—ì„œ ì˜¤ëŠ˜ì˜ ì¶”ì²œ ê³¡ ë° í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ë¥¼ ê°€ì ¸ì™€ index.htmlì— ë Œë”ë§`
    > 
    >          `ì‚¬ìš©ì ê²€ìƒ‰ ìš”ì²­ì„ ë°›ì•„ Airflow DAG í˜¸ì¶œ`
    > 
    >          `ê²€ìƒ‰ì–´ì™€ í”Œë«í¼ì— ë”°ë¥¸ ê²°ê³¼ ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ result.htmlì— ë Œë”ë§`
    > 
    > **`ğŸ“‘ Django REST API`**
    > 
    > - [**`Django view ë¡œì§`**]
    >     
    >     ```html
    >     <!-- ê²€ìƒ‰ì–´ ì…ë ¥ ë°›ê¸°: frontend -->
    >     <form method="post" action="/trigger-dag/">
    >         {% csrf_token %}
    >         <input type="text" name="input_value" placeholder="Enter value">
    >         <button type="submit">Trigger DAG</button>
    >     </form>
    >     ```
    >     
    >     ```python
    >     # ì…ë ¥ë°›ì€ ê²€ìƒ‰ì–´ Airflowë¡œ ë³´ë‚´ê¸°: Beckend
    >     import requests
    >     from django.http import JsonResponse
    >     from requests.auth import HTTPBasicAuth
    >     
    >     def trigger_airflow_dag(request):
    >         if request.method == "POST":
    >             input_value = request.POST.get("input_value")  # form-dataì—ì„œ keyê°’ì— í•´ë‹¹í•˜ëŠ” ê°’ ê°€ì ¸ì˜¤ê¸°
    >             
    >             if not input_value:
    >                 return JsonResponse({"error": "No input_value provided"}, status=400)
    >     
    >             airflow_url = "http://localhost:8080/api/v1/dags/example_trigger_dag/dagRuns" # ìš”ì²­ url
    >             username = 'your_username'
    >             password = 'your_password'
    >     
    >             payload = {
    >                 "conf": {"input_value": input_value}
    >             }
    >     
    >             headers = {
    >                 'Content-Type': 'application/json',  # ìš”ì²­ ë³¸ë¬¸ í˜•ì‹ì„ JSONìœ¼ë¡œ ì„¤ì •
    >                 'Accept': 'application/json',         # ì‘ë‹µ í˜•ì‹ë„ JSONìœ¼ë¡œ ì„¤ì •
    >             }
    >     
    >             try:
    >                 response = requests.post(airflow_url, json=payload, headers=headers, auth=HTTPBasicAuth(username, password))
    >     
    >                 if response.status_code == 200:
    >                     return JsonResponse({"message": "DAG triggered successfully!"})
    >                 else:
    >                     return JsonResponse({"error": response.json()}, status=response.status_code)
    >             except Exception as e:
    >                 return JsonResponse({"error": str(e)}, status=500)
    >     
    >         return JsonResponse({"error": "Invalid request method"}, status=405)
    >     
    >     ```
    >     
    > 
    >         `ì‚¬ìš©ì ì…ë ¥ê°’ì„ Django ì›¹ì•±ì—ì„œ ìˆ˜ì§‘`
    > 
    >         `Djangoê°€ Airflow REST API í˜¸ì¶œ: ì…ë ¥ê°’ì„ Airflowì˜ DAGë¡œ ì „ë‹¬`
    > 
    > - [**`Airflow DAG`**]
    >     
    >     ```python
    >     # DAG ì˜ˆì‹œ
    >     from airflow import DAG
    >     from airflow.operators.python import PythonOperator
    >     from datetime import datetime
    >     
    >     def process_input_value(**kwargs):
    >         # Djangoì—ì„œ ì „ë‹¬í•œ conf ê°’ ê°€ì ¸ì˜¤ê¸°
    >         input_value = kwargs['dag_run'].conf.get('input_value', 'default_value')  # ê¸°ë³¸ê°’ ì„¤ì •
    >         print(f"Received input value: {input_value}")
    >         # ì²˜ë¦¬ ë¡œì§ ì¶”ê°€
    >         return f"Processed input value: {input_value}"
    >     
    >     # DAG ì •ì˜
    >     with DAG(
    >         dag_id="example_trigger_dag",
    >         start_date=datetime(2023, 1, 1),  # DAG ì‹œì‘ì¼ ì„¤ì •
    >         schedule_interval=None,  # ìŠ¤ì¼€ì¤„ ì—†ìŒ (ì™¸ë¶€ íŠ¸ë¦¬ê±°ë¡œë§Œ ì‹¤í–‰)
    >         catchup=False,  # ë°±í•„ ì‹¤í–‰ ë°©ì§€
    >     ) as dag:
    >         process_task = PythonOperator(
    >             task_id="process_input_value",
    >             python_callable=process_input_value,
    >             provide_context=True,  # context ì „ë‹¬
    >         )
    >     ```
    >     
    > 
    >        `Airflow DAGì—ì„œ ì…ë ¥ê°’ ì²˜ë¦¬: dag_run.confë¡œ ì „ë‹¬ëœ ì…ë ¥ê°’ì„ ìˆ˜ì‹ í•˜ê³  ì²˜ë¦¬`
    > 
    
    **í”„ë¡ íŠ¸ì—”ë“œ (Template)**
    
    > **`ğŸ“‘ Template`**
    > 
    > - [**`index.html`**] `(ë©”ì¸ í˜ì´ì§€)`
    >     
    >     ```html
    >     <!DOCTYPE html>
    >     <html lang="en">
    >     <head>
    >         {% load static %}
    >         <meta charset="UTF-8">
    >         <meta name="viewport" content="width=device-width, initial-scale=1.0">
    >         <link rel="stylesheet" type="text/css" href="{% static 'search/css/index.css' %}">
    >         <title>ì˜¥íƒ‘ë°© í”Œë ˆì´ë¦¬ìŠ¤íŠ¸</title>
    >     </head>
    >     <body>
    >         <header>
    >             <h1>ì˜¥íƒ‘ë°© í”Œë ˆì´ë¦¬ìŠ¤íŠ¸</h1>
    >         </header>
    >     
    >         <main>
    >             <!-- ê²€ìƒ‰ì°½ -->
    >             <form action="{% url 'trigger_dag' %}" method="POST">
    >                 {% csrf_token %}
    >                 <input type="radio" id="youtube" name="platform" value="youtube"> YouTube
    >                 <input type="radio" id="spotify" name="platform" value="spotify"> Spotify
    >                 <input type="text" name="input_value" placeholder="ë…¸ë˜ ì œëª© í˜¹ì€ ê°€ìˆ˜ëª…" required>
    >             </form>
    >     
    >             <!-- ì¸ê¸° ì°¨íŠ¸ -->
    >             <div class="playlist">
    >                 <h2>{{ current_date }} ì¸ê¸° ì°¨íŠ¸</h2>
    >                 <div class="scroll-container">
    >                     {% for song in daily_songs %}
    >                         <div class="scroll-item">
    >                             <a href="{{ song.song_url }}" target="_blank">
    >                                 <img src="{{ song.thumbnail }}" alt="{{ song.song_title }}">
    >                                 <p>{{ song.song_title }}</p>
    >                             </a>
    >                         </div>
    >                     {% endfor %}
    >                 </div>
    >             </div>
    >     
    >             <!-- ì¶”ì²œ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ -->
    >             <div class="playlist">
    >                 <h2>ì¶”ì²œ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸</h2>
    >                 <div class="scroll-container">
    >                     {% for playlist in daily_playlists %}
    >                         <div class="scroll-item">
    >                             <iframe src="{{ playlist.playlist_url }}" width="300" height="380"></iframe>
    >                         </div>
    >                     {% endfor %}
    >                 </div>
    >             </div>
    >         </main>
    >     
    >         <footer>
    >             <p>@ made by 007</p>
    >         </footer>
    >     </body>
    >     </html>
    >     
    >     ```
    >     
    > 
    >          `ë…¸ë˜ ê²€ìƒ‰ / í”Œë«í¼ í•„í„° - í•„í„°ì— ë§ëŠ” ê²€ìƒ‰ ê²°ê³¼ ì œê³µ`
    > 
    >          `ì˜¤ëŠ˜ì˜ Youtube/Spotify ì¸ê¸° ì°¨íŠ¸ ë° í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ì œê³µ`
    > 
    > - [**`result.html`**] `(ê²€ìƒ‰ ê²°ê³¼ í˜ì´ì§€)`
    >     
    >     ```html
    >     <!DOCTYPE html>
    >     <html lang="en">
    >     <head>
    >         {% load static %}
    >         <meta charset="UTF-8">
    >         <meta name="viewport" content="width=device-width, initial-scale=1.0">
    >         <link rel="stylesheet" type="text/css" href="{% static 'search/css/result.css' %}">
    >         <title>ì˜¥íƒ‘ë°© í”Œë ˆì´ë¦¬ìŠ¤íŠ¸</title>
    >     </head>
    >     <body>
    >         <!-- í—¤ë” -->
    >         <header>
    >             <h1>ì˜¥íƒ‘ë°© í”Œë ˆì´ë¦¬ìŠ¤íŠ¸</h1>
    >         </header>
    >     
    >         <div class="main-container">
    >             <!-- ì‚¬ì´ë“œë°” -->
    >             <aside class="sidebar">
    >                 <p class="sidebar-title">MENU</p>
    >                 <button id="youtube-button" class="{% if platform == 'youtube' %}active{% endif %}">YouTube</button>
    >                 <button id="spotify-button" class="{% if platform == 'spotify' %}active{% endif %}">Spotify</button>
    >             </aside>
    >     
    >             <!-- ë©”ì¸ ì½˜í…ì¸  -->
    >             <div class="main-content">
    >                 <!-- ê²€ìƒ‰ì°½ -->
    >                 <form action="{% url 'trigger_dag' %}" method="POST">
    >                     {% csrf_token %}
    >                     <input type="radio" id="youtube" name="platform" value="youtube"> YouTube
    >                     <input type="radio" id="spotify" name="platform" value="spotify"> Spotify
    >                     <input type="text" name="input_value" placeholder="ë…¸ë˜ ì œëª© í˜¹ì€ ê°€ìˆ˜ëª…" required>
    >                 </form>
    >     
    >                 <!-- ê²€ìƒ‰ê²°ê³¼ -->
    >                 <section class="result-container">
    >                     <!-- YouTube ì¶”ì²œ -->
    >                     {% if platform == 'youtube' %}
    >                         <div id="youtube-section">
    >                             <!-- ì¶”ì²œ ë…¸ë˜ -->
    >                             <div class="youtube-videos-container">
    >                                 <h2>YouTube ì¶”ì²œ ê³¡</h2>
    >                                 {% for song in search_songs %}
    >                                     <div>{{ song.song_title }}</div>
    >                                 {% endfor %}
    >                             </div>
    >                             <!-- ì¶”ì²œ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ -->
    >                             <div class="youtube-playlist-container">
    >                                 <h2>YouTube ì¶”ì²œ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸</h2>
    >                                 {% for playlist in search_playlists %}
    >                                     <div>{{ playlist.playlist_title }}</div>
    >                                 {% endfor %}
    >                             </div>
    >                         </div>
    >                     {% endif %}
    >     
    >                     <!-- Spotify ì¶”ì²œ -->
    >                     {% if platform == 'spotify' %}
    >                         <div id="spotify-section">
    >                             <!-- ì¶”ì²œ ë…¸ë˜ -->
    >                             <div class="spotify-recommend-container">
    >                                 <h2>Spotify ì¶”ì²œ ê³¡</h2>
    >                                 {% for song in search_songs %}
    >                                     <div>{{ song.song_title }}</div>
    >                                 {% endfor %}
    >                             </div>
    >                             <!-- ì¶”ì²œ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ -->
    >                             <div class="spotify-playlist-container">
    >                                 <h2>Spotify ì¶”ì²œ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸</h2>
    >                                 {% for playlist in search_playlists %}
    >                                     <div>{{ playlist.playlist_title }}</div>
    >                                 {% endfor %}
    >                             </div>
    >                         </div>
    >                     {% endif %}
    >                 </section>
    >             </div>
    >         </div>
    >     
    >         <!-- ëª¨ë‹¬ -->
    >         <div class="modal" id="modal">
    >             <div class="modal-content">
    >                 <h2>ë…¸ë˜ ì¬ìƒ</h2>
    >                 <iframe id="youtube-player"></iframe>
    >             </div>
    >         </div>
    >     
    >         <!-- Toast ë©”ì‹œì§€ -->
    >         <div id="toast" class="toast"></div>
    >     
    >         <!-- JavaScript -->
    >         <script src="{% static 'search/js/result.js' %}"></script>
    >     </body>
    >     </html>
    >     ```
    >     
    > 
    >          `ë…¸ë˜ ì¬ê²€ìƒ‰ / í”Œë«í¼ í•„í„° - í•„í„°ì— ë§ëŠ” ê²€ìƒ‰ ê²°ê³¼ ì œê³µ`
    > 
    >          `í•´ë‹¹ ë…¸ë˜ì˜ Youtube/Spotify ì¶”ì²œ ê³¡ ë° í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ì œê³µ`
    > 
    >          `Youtube Videoì— ëŒ€í•œ ëª¨ë‹¬ ê¸°ëŠ¥ ì œê³µ - ìŒì•… í”Œë ˆì´ì–´`
    > 
</aside>

## V. ê¸°ëŒ€íš¨ê³¼ ë° í•œê³„ì 

<aside>

### ğŸ‘ğŸ½ ê¸°ëŒ€íš¨ê³¼

1. **í†µí•© ê²€ìƒ‰ìœ¼ë¡œ ì‹œê°„ ì ˆì•½**
    
    > ê¸°ì¡´ì—ëŠ” YouTubeì™€ Spotifyì—ì„œ ì›í•˜ëŠ” ë…¸ë˜ë¥¼ ê°ê° ê²€ìƒ‰í•´ì•¼ ì›í•˜ëŠ” ì½˜í…ì¸ ë¥¼ ì°¾ì„ ìˆ˜ ìˆì—ˆìŒ
    > 
    
    > í•´ë‹¹ í”„ë¡œì íŠ¸ë¡œ **`ë‘ í”Œë«í¼ì˜ ë°ì´í„°ë¥¼ í†µí•©ì ìœ¼ë¡œ ì œê³µ`**í•˜ì—¬ **`í•œ ë²ˆì˜ ê²€ìƒ‰`**ìœ¼ë¡œ ê´€ë ¨ëœ ìŒì•…ê³¼ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ì¶”ì²œ
    > 
2. **ë‹¤ì–‘í•œ ì¶”ì²œ ì½˜í…ì¸  ì œê³µ**
    
    > **YouTube** : ì‚¬ìš©ìê°€ ë§Œë“  ì½˜í…ì¸ (ì»¤ë²„ê³¡, ë¼ì´ë¸Œ ì˜ìƒ ë“± video)ê°€ í’ë¶€
    **Spotify** : ì „ë¬¸ì ìœ¼ë¡œ íë ˆì´íŒ…ëœ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ë¥¼ ì œê³µ
    > 
    
    > **`ë‘ í”Œë«í¼ì˜ íŠ¹ì„±ì„ ê²°í•©`**í•˜ì—¬ ì‚¬ìš©ìì—ê²Œ **`ë‹¤ì–‘í•œ ì„ íƒì§€ë¥¼ ì œê³µ`**
    > 
3. **ê²€ìƒ‰ê³¼ ë™ì‹œì— ì¬ìƒ ê°€ëŠ¥**
    
    > ê° í”Œë«í¼ì—ì„œ ì¶”ì²œ ë°›ì€ ë…¸ë˜ë¥¼ **`ì›¹í˜ì´ì§€ì—ì„œ ë°”ë¡œ ì¬ìƒ`**ì´ ê°€ëŠ¥í•˜ë„ë¡ Web UI ì œê³µ
    > 
4. **ê²€ìƒ‰ê³¼ ë™ì‹œì— playlist ì¶”ê°€ ê°€ëŠ¥**
    
    > ê° í”Œë«í¼ì—ì„œ ì¶”ì²œ ë°›ì€ playlistë¥¼ **`ì›¹í˜ì´ì§€ì—ì„œ ë°”ë¡œ í”Œë«í¼ì˜ playlistë¡œ ì¶”ê°€`**í•  ìˆ˜ ìˆë„ë¡ Web UI ì œê³µ
    > 

### â˜ğŸ½ í•œê³„ì  ë° ê°œì„ ì 

1. **ì‚¬ìš©ì ì„ í˜¸ ë°˜ì˜ í•œê³„**
    
    > í˜„ì¬ ì‹œìŠ¤í…œì€ **`ê²€ìƒ‰ì–´ ê¸°ë°˜ì˜ ì¶”ì²œ`**ìœ¼ë¡œ, ê°œë³„ ì‚¬ìš©ìì˜ ì„ í˜¸ë‚˜ ì²­ì·¨ ì´ë ¥ê³¼ ê°™ì€ ì‹¬í™” ì •ë³´ë¥¼ ë°˜ì˜í•˜ê¸° ì–´ë ¤ì›€.
    > 
2. **ë§ì¶¤í˜• ì¶”ì²œ ê¸°ëŠ¥ ì¶”ê°€**
    
    > ì‚¬ìš©ìì˜ ì²­ì·¨ ì´ë ¥, ì¢‹ì•„ìš” ê¸°ë¡, ì¦ê²¨ì°¾ê¸° ë°ì´í„°ë¥¼ ì €ì¥ ë° ë¶„ì„í•˜ì—¬ **`ê°œì¸ ë§ì¶¤í˜• ì¶”ì²œ`** ì œê³µ
    > 
3. **ì¶”ì²œ ì‚¬ì´íŠ¸ í™•ì¥**
    
    > spotify, youtube ì™¸ì— **`ë‹¤ë¥¸ ìŒì› ì‚¬ì´íŠ¸ì˜ ì¶”ì²œ ë¦¬ìŠ¤íŠ¸ ë° ì¶”ì²œê³¡`**ì„ ë°›ì•„ì˜¬ ìˆ˜ ìˆë„ë¡ api ì‚¬ìš© í™•ì¥
    > 
</aside>

## VI.  ì§„í–‰ê³¼ì • ë° ë¦¬ë·°

<aside>

### **ğŸ”± Strategy**

- êµ¬í˜„í•  ê¸°ëŠ¥ë“¤ì„ ì„¸ ê°€ì§€ë¡œ íŒŒíŠ¸ë¡œ ë¶„ë¥˜í•˜ì—¬ êµ¬í˜„, **`ê° ê¸°ëŠ¥ì— ëŒ€í•œ ê¸°ìˆ ì„ ì‚¬ìš©í•˜ê³  ì´í•´`**
- ë°ì´í„° **`ì¶”ì¶œ(Extract)`**, **`ë³€í™˜(Transform)`**, **`ì ì¬(Load)`** ê³¼ì •ì¸ ETL/ELT ì´í•´ ë° êµ¬í˜„
- **`airflow`** ë° **`docker`** ì‚¬ìš©ë²•ì— ëŒ€í•œ ì´í•´ ë° êµ¬í˜„
- **`django`**ì™€ **`airflow`**ì˜ **`connection`** ë° **`dag trigger`** ì´í•´ ë° êµ¬í˜„


### ğŸ’¯ ê¸°ìˆ ì  ì„±ì·¨ë„

| Practical solution | â˜…â˜…â˜…â˜…â˜… |
| --- | --- |
| Visualization | â˜…â˜…â˜…â˜…â˜… |
| Maintainability | â˜…â˜…â˜…â˜…â˜… |
| Flexibility | â˜…â˜…â˜…â˜…â˜† |
| Integration | â˜…â˜…â˜…â˜…â˜… |
</aside>

</aside>
